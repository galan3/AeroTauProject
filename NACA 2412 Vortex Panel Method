import os
import numpy as np
import matplotlib.pyplot as plt
import math


def load_points(plot):
    points = np.loadtxt('naca2412.dat', skiprows=1)
    points = np.flipud(points)
    n = np.shape(points)[0] - 1
    centroids = np.zeros((n, 2))
    for i in range(0, n):
        centroids[i, 0] = 0.5 * (points[i, 0] + points[i + 1, 0])
        centroids[i, 1] = 0.5 * (points[i, 1] + points[i + 1, 1])

    plot.plot(points[:, 0], points[:, 1])
    plot.set_xlabel('x/c')
    plot.set_ylabel('y/c')
    plot.set_title('Airfoil with Wake Vortex Panels')
    plot.set_ylim([-0.5, 0.5])

    os.makedirs('plots', exist_ok=True)
    plt.savefig('plots/airfoil_with_vortex.pdf')

    return n, points, centroids


def sweep(minalpha, maxalpha, alphastep, n, points, centroids, plotcl, plotcp):
    alpha_plot = []
    cl_plot = []

    alpha = minalpha
    while alpha <= maxalpha:
        cl = solve_panel_with_wake(points, centroids, n, math.pi * alpha / 180, plotcp)
        if cl < 1.3:
            print('Angle:', alpha, ' Cl:', cl)
        else:
            print('Angle:', alpha, ' Cl:', cl, ' WARNING: Stall Likely!')
        alpha_plot.append(alpha)
        cl_plot.append(cl)
        alpha += alphastep

    plotcl.plot(alpha_plot, cl_plot, marker=".", markersize=6, label=r'$C_L$')
    plotcl.legend()
    plotcl.set_xlabel(r'$\alpha$')
    plotcl.set_ylabel(r'$C_L$')
    plotcl.set_title('Lift Curve with Wake Vortex Panels')

    os.makedirs('data', exist_ok=True)
    np.savetxt('data/cl_with_wake.txt', np.c_[alpha_plot, cl_plot], delimiter=' ')
    return


def solve_panel_with_wake(points, centroids, n, alpha, plot):
    jmat = np.zeros((n, n))
    kmat = np.zeros((n, n))
    amat = np.zeros((n + 1, n + 1))
    vvec = np.zeros((n + 1, 1))
    svec = np.zeros((n + 1, 1))
    gamma_wake = np.zeros(n)

    for i in range(0, n):
        for j in range(0, n):
            if j != i:
                a, d, e, f, g, sj, c1, c2 = coefficients(points, centroids, i, j)
                jmat[i, j] = -c2 / 2 * f - c1 * g
                kmat[i, j] = -c2 + 1 / sj * ((a * c2 + d / 2) * f + (a * c1 + e * c2) * g)
                svec[j] = sj
            else:
                kmat[i, j] = -1

    # Adding wake influence
    wake_length = 5.0  # Length of wake (can be adjusted based on flow)
    wake_points = np.array([[points[-1, 0] + wake_length, 0], [points[-1, 0], 0]])  # Simple linear wake

    for i in range(0, n):
        amat[i, :-1] = jmat[i, :] - kmat[i, :]
        amat[i, -1] = np.sum(kmat[i, :])  # Add wake panel influence

        angle = math.atan2((points[i + 1, 1] - points[i, 1]), (points[i + 1, 0] - points[i, 0]))
        vvec[i] = 2 * math.pi * math.sin(alpha - angle)

    # Solve the circulation (gamma) using Kutta condition
    amat[n, 0] = 1.0
    amat[n, n] = 1.0
    gamma = np.linalg.solve(amat, vvec)

    # Calculate circulation in the wake
    gamma_wake = np.sum(gamma[:-1])

    # Calculate lift coefficient by integrating circulation
    cl = 0
    for i in range(0, n):
        cl += 0.5 * (gamma[i] + gamma[i + 1]) * svec[i]
    cl = cl[0] / 0.5

    cp = 1 - (gamma[:-1] ** 2)
    plot.plot(points[2:-2, 0], -cp[2:-2], label=r'$\alpha = $' + str(alpha / math.pi * 180))
    plot.legend()
    plot.set_xlabel('x/c')
    plot.set_ylabel(r'$C_P$')
    plot.set_title('Pressure Coefficient with Wake Panels')

    os.makedirs('data', exist_ok=True)
    np.savetxt('data/cp_with_wake_' + str(alpha / math.pi * 180) + '.txt', np.c_[points[2:-2, 0], cp[2:-2]], delimiter=' ')

    return cl


def coefficients(points, centroids, i, j):
    phii = math.atan2((points[i + 1, 1] - points[i, 1]), (points[i + 1, 0] - points[i, 0]))
    phij = math.atan2((points[j + 1, 1] - points[j, 1]), (points[j + 1, 0] - points[j, 0]))

    a = -(centroids[i, 0] - points[j, 0]) * math.cos(phij) - (centroids[i, 1] - points[j, 1]) * math.sin(phij)
    b = (centroids[i, 0] - points[j, 0]) ** 2 + (centroids[i, 1] - points[j, 1]) ** 2
    c1 = math.sin(phii - phij)
    c2 = math.cos(phii - phij)
    d = (centroids[i, 0] - points[j, 0]) * math.cos(phii) + (centroids[i, 1] - points[j, 1]) * math.sin(phii)
    sj = math.sqrt((points[j + 1, 0] - points[j, 0]) ** 2 + (points[j + 1, 1] - points[j, 1]) ** 2)

    if b - a ** 2 < 0:
        e = 0
    else:
        e = math.sqrt(b - a ** 2)

    if e == 0:
        f = 0
        g = 0
    else:
        f = math.log((sj ** 2 + 2 * a * sj + b) / b)
        g = math.atan((sj + a) / e) - math.atan(a / e)

    return a, d, e, f, g, sj, c1, c2


# Main execution
if __name__ == "__main__":
    fig, ax = plt.subplots()
    fig_cl, ax_cl = plt.subplots()
    fig_cp, ax_cp = plt.subplots()

    n, points, centroids = load_points(ax)
    minalpha = -4
    maxalpha = 13
    alphastep = 1
    sweep(minalpha, maxalpha, alphastep, n, points, centroids, ax_cl, ax_cp)

    plt.show()
